"""
LinkedIn Auto-Poster - Generates and posts content to LinkedIn.

Posts go through the approval workflow:
1. Claude generates a draft based on Business_Goals.md
2. Draft is saved to /Pending_Approval/LINKEDIN_POST_<date>.md
3. Human reviews and moves to /Approved/ or /Rejected/
4. Scheduler picks up approved posts and publishes them

Requires:
    - LinkedIn App with OAuth 2.0 access token
    - See docs/LINKEDIN_SETUP.md for setup instructions

Usage:
    python -m skills.linkedin_poster              # Create draft for approval
    python -m skills.linkedin_poster --post FILE  # Post an approved file
"""

import os
import json
import logging
from pathlib import Path
from datetime import datetime, timezone

import httpx
from dotenv import load_dotenv

load_dotenv(override=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("LinkedInPoster")

DEFAULT_VAULT = Path(__file__).parent.parent / "AI_Employee_Vault"

LINKEDIN_API_URL = "https://api.linkedin.com/rest/posts"


def get_linkedin_config() -> dict | None:
    """Load LinkedIn credentials from environment."""
    token = os.getenv("LINKEDIN_ACCESS_TOKEN")
    person_urn = os.getenv("LINKEDIN_PERSON_URN")

    if not token or not person_urn:
        logger.error(
            "LINKEDIN_ACCESS_TOKEN and LINKEDIN_PERSON_URN must be set in .env. "
            "See docs/LINKEDIN_SETUP.md for setup instructions."
        )
        return None

    return {"access_token": token, "person_urn": person_urn}


def post_to_linkedin(text: str, config: dict) -> dict:
    """
    Post content to LinkedIn using the Posts API.

    Returns dict with 'success' boolean and 'response' or 'error'.
    """
    dry_run = os.getenv("DRY_RUN", "true").lower() == "true"

    if dry_run:
        logger.info("[DRY RUN] Would post to LinkedIn:")
        logger.info(text[:200])
        return {"success": True, "dry_run": True, "message": "Post simulated (DRY_RUN=true)"}

    headers = {
        "Authorization": f"Bearer {config['access_token']}",
        "Content-Type": "application/json",
        "X-Restli-Protocol-Version": "2.0.0",
        "LinkedIn-Version": "202502",
    }

    payload = {
        "author": config["person_urn"],
        "commentary": text,
        "visibility": "PUBLIC",
        "distribution": {
            "feedDistribution": "MAIN_FEED",
            "targetEntities": [],
            "thirdPartyDistributionChannels": [],
        },
        "lifecycleState": "PUBLISHED",
        "isReshareDisabledByAuthor": False,
    }

    try:
        response = httpx.post(LINKEDIN_API_URL, headers=headers, json=payload, timeout=30)

        if response.status_code in (200, 201):
            logger.info("Successfully posted to LinkedIn")
            return {"success": True, "status_code": response.status_code}
        else:
            logger.error(f"LinkedIn API error: {response.status_code} {response.text}")
            return {"success": False, "error": f"{response.status_code}: {response.text}"}

    except httpx.HTTPError as e:
        logger.error(f"HTTP error posting to LinkedIn: {e}")
        return {"success": False, "error": str(e)}


def create_post_draft(vault: Path | None = None):
    """
    Create a LinkedIn post draft in /Pending_Approval for human review.

    Reads Business_Goals.md for context to guide content generation.
    The actual post content is generated by Claude via the orchestrator.
    """
    vault = vault or DEFAULT_VAULT

    pending = vault / "Pending_Approval"
    pending.mkdir(parents=True, exist_ok=True)

    now = datetime.now(timezone.utc).isoformat()
    date_str = datetime.now().strftime("%Y-%m-%d")
    filename = f"LINKEDIN_POST_{date_str}.md"
    filepath = pending / filename

    # Check if draft already exists today
    if filepath.exists():
        logger.info(f"Draft already exists for today: {filename}")
        return filepath

    # Read business goals for context
    goals_path = vault / "Business_Goals.md"
    goals_context = ""
    if goals_path.exists():
        goals_context = goals_path.read_text(encoding="utf-8")

    content = f"""---
type: linkedin_post
action: linkedin_post
status: pending_approval
created: {now}
priority: medium
---

# LinkedIn Post Draft - {date_str}

## Business Context
{goals_context or "_No Business_Goals.md found. Add one to guide post generation._"}

## Post Content
<!-- Claude will fill this in when processing via orchestrator -->
<!-- Replace this section with your post text before approving -->

_Draft pending: Run the orchestrator or use /draft-linkedin-post to generate content._

## Instructions
1. Review and edit the post content above
2. Move this file to `/Approved/` to publish
3. Move to `/Rejected/` to discard
"""
    filepath.write_text(content, encoding="utf-8")
    logger.info(f"Created LinkedIn post draft: {filename}")
    return filepath


def execute_approved_post(approved_file: Path) -> dict:
    """Execute an approved LinkedIn post from /Approved."""
    config = get_linkedin_config()
    if not config:
        return {"success": False, "error": "LinkedIn not configured"}

    content = approved_file.read_text(encoding="utf-8")

    # Extract post text between "## Post Content" and the next "##" or end
    post_text = ""
    in_post_section = False
    lines = content.split("\n")
    for line in lines:
        if line.startswith("## Post Content"):
            in_post_section = True
            continue
        if in_post_section and line.startswith("## "):
            break
        if in_post_section:
            post_text += line + "\n"

    post_text = post_text.strip()

    # Remove HTML comments and placeholder text
    if not post_text or post_text.startswith("<!--") or post_text.startswith("_Draft pending"):
        return {"success": False, "error": "Post content is empty or still a placeholder. Edit before approving."}

    return post_to_linkedin(post_text, config)


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 2 and sys.argv[1] == "--post":
        result = execute_approved_post(Path(sys.argv[2]))
        print(json.dumps(result, indent=2))
    else:
        create_post_draft()
